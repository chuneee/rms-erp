{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { isDOM } from \"rc-util/es/Dom/findDOMNode\";\nimport isVisible from \"rc-util/es/Dom/isVisible\";\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getWin } from \"../util\";\n\nfunction toNum(num) {\n  return Number.isNaN(num) ? 1 : num;\n}\n\nfunction splitPoints() {\n  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return [points[0], points[1]];\n}\n\nfunction getAlignPoint(rect, points) {\n  var topBottom = points[0];\n  var leftRight = points[1];\n  var x;\n  var y; // Top & Bottom\n\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  } // Left & Right\n\n\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction reversePoints(points, index) {\n  var reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  return points.map(function (point, i) {\n    if (i === index) {\n      return reverseMap[point] || 'c';\n    }\n\n    return point;\n  }).join('');\n}\n\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {\n  var _React$useState = React.useState({\n    ready: false,\n    offsetX: 0,\n    offsetY: 0,\n    arrowX: 0,\n    arrowY: 0,\n    scaleX: 1,\n    scaleY: 1,\n    align: builtinPlacements[placement] || {}\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      offsetInfo = _React$useState2[0],\n      setOffsetInfo = _React$useState2[1];\n\n  var alignCountRef = React.useRef(0);\n  var scrollerList = React.useMemo(function () {\n    if (!popupEle) {\n      return [];\n    }\n\n    return collectScroller(popupEle);\n  }, [popupEle]); // ========================= Align =========================\n\n  var onAlign = useEvent(function () {\n    if (popupEle && target && open) {\n      var popupElement = popupEle;\n      var originLeft = popupElement.style.left;\n      var originTop = popupElement.style.top;\n      var doc = popupElement.ownerDocument;\n      var win = getWin(popupElement); // Placement\n\n      var placementInfo = _objectSpread(_objectSpread({}, builtinPlacements[placement]), popupAlign); // Reset first\n\n\n      popupElement.style.left = '0';\n      popupElement.style.top = '0'; // Calculate align style, we should consider `transform` case\n\n      var targetRect;\n\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        var rect = target.getBoundingClientRect();\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n\n      var popupRect = popupElement.getBoundingClientRect();\n\n      var _win$getComputedStyle = win.getComputedStyle(popupElement),\n          width = _win$getComputedStyle.width,\n          height = _win$getComputedStyle.height;\n\n      var _doc$documentElement = doc.documentElement,\n          clientWidth = _doc$documentElement.clientWidth,\n          clientHeight = _doc$documentElement.clientHeight,\n          scrollWidth = _doc$documentElement.scrollWidth,\n          scrollHeight = _doc$documentElement.scrollHeight,\n          scrollTop = _doc$documentElement.scrollTop,\n          scrollLeft = _doc$documentElement.scrollLeft;\n      var popupHeight = popupRect.height;\n      var popupWidth = popupRect.width;\n      var targetHeight = targetRect.height;\n      var targetWidth = targetRect.width; // Get bounding of visible area\n\n      var visibleArea = placementInfo.htmlRegion === 'scroll' ? // Scroll region should take scrollLeft & scrollTop into account\n      {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      } : {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      (scrollerList || []).forEach(function (ele) {\n        if (ele instanceof HTMLBodyElement) {\n          return;\n        }\n\n        var eleRect = ele.getBoundingClientRect();\n        var eleOutHeight = ele.offsetHeight,\n            eleInnerHeight = ele.clientHeight,\n            eleOutWidth = ele.offsetWidth,\n            eleInnerWidth = ele.clientWidth;\n        var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n        var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);\n        var eleScrollWidth = (eleOutWidth - eleInnerWidth) * scaleX;\n        var eleScrollHeight = (eleOutHeight - eleInnerHeight) * scaleY;\n        var eleRight = eleRect.x + eleRect.width - eleScrollWidth;\n        var eleBottom = eleRect.y + eleRect.height - eleScrollHeight;\n        visibleArea.left = Math.max(visibleArea.left, eleRect.left);\n        visibleArea.top = Math.max(visibleArea.top, eleRect.top);\n        visibleArea.right = Math.min(visibleArea.right, eleRight);\n        visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n      }); // Reset back\n\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop; // Calculate scale\n\n      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n\n      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000); // No need to align since it's not visible in view\n\n\n      if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      } // Offset\n\n\n      var offset = placementInfo.offset,\n          targetOffset = placementInfo.targetOffset;\n\n      var _ref = offset || [],\n          _ref2 = _slicedToArray(_ref, 2),\n          _ref2$ = _ref2[0],\n          popupOffsetX = _ref2$ === void 0 ? 0 : _ref2$,\n          _ref2$2 = _ref2[1],\n          popupOffsetY = _ref2$2 === void 0 ? 0 : _ref2$2;\n\n      var _ref3 = targetOffset || [],\n          _ref4 = _slicedToArray(_ref3, 2),\n          _ref4$ = _ref4[0],\n          targetOffsetX = _ref4$ === void 0 ? 0 : _ref4$,\n          _ref4$2 = _ref4[1],\n          targetOffsetY = _ref4$2 === void 0 ? 0 : _ref4$2;\n\n      targetRect.x += targetOffsetX;\n      targetRect.y += targetOffsetY; // Points\n\n      var _ref5 = placementInfo.points || [],\n          _ref6 = _slicedToArray(_ref5, 2),\n          popupPoint = _ref6[0],\n          targetPoint = _ref6[1];\n\n      var targetPoints = splitPoints(targetPoint);\n      var popupPoints = splitPoints(popupPoint);\n      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      var popupAlignPoint = getAlignPoint(popupRect, popupPoints); // Real align info may not same as origin one\n\n      var nextAlignInfo = _objectSpread({}, placementInfo); // Next Offset\n\n\n      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY; // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n\n      function getIntersectionVisibleArea(x, y) {\n        var r = x + popupWidth;\n        var b = y + popupHeight;\n        var visibleX = Math.max(x, visibleArea.left);\n        var visibleY = Math.max(y, visibleArea.top);\n        var visibleR = Math.min(r, visibleArea.right);\n        var visibleB = Math.min(b, visibleArea.bottom);\n        return (visibleR - visibleX) * (visibleB - visibleY);\n      }\n\n      var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY); // ================ Overflow =================\n\n      var targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      var popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      var targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      var popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      var overflow = placementInfo.overflow || {};\n      var adjustX = overflow.adjustX,\n          adjustY = overflow.adjustY,\n          shiftX = overflow.shiftX,\n          shiftY = overflow.shiftY;\n\n      var supportAdjust = function supportAdjust(val) {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n\n        return val >= 0;\n      }; // >>>>>>>>>> Top & Bottom\n\n\n      var nextPopupY = popupRect.y + nextOffsetY;\n      var nextPopupBottom = nextPopupY + popupHeight;\n      var needAdjustY = supportAdjust(adjustY);\n      var sameTB = popupPoints[0] === targetPoints[0]; // Bottom to Top\n\n      if (needAdjustY && popupPoints[0] === 't' && nextPopupBottom > visibleArea.bottom) {\n        var tmpNextOffsetY;\n\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n\n        if (getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY) > originIntersectionVisibleArea) {\n          nextOffsetY = tmpNextOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        }\n      } // Top to Bottom\n\n\n      if (needAdjustY && popupPoints[0] === 'b' && nextPopupY < visibleArea.top) {\n        var _tmpNextOffsetY;\n\n        if (sameTB) {\n          _tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n\n        if (getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY) > originIntersectionVisibleArea) {\n          nextOffsetY = _tmpNextOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        }\n      } // >>>>>>>>>> Left & Right\n\n\n      var nextPopupX = popupRect.x + nextOffsetX;\n      var nextPopupRight = nextPopupX + popupWidth;\n      var needAdjustX = supportAdjust(adjustX); // >>>>> Flip\n\n      var sameLR = popupPoints[1] === targetPoints[1]; // Right to Left\n\n      if (needAdjustX && popupPoints[1] === 'l' && nextPopupRight > visibleArea.right) {\n        var tmpNextOffsetX;\n\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n\n        if (getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY) > originIntersectionVisibleArea) {\n          nextOffsetX = tmpNextOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        }\n      } // Left to Right\n\n\n      if (needAdjustX && popupPoints[1] === 'r' && nextPopupX < visibleArea.left) {\n        var _tmpNextOffsetX;\n\n        if (sameLR) {\n          _tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n\n        if (getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY) > originIntersectionVisibleArea) {\n          nextOffsetX = _tmpNextOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        }\n      } // >>>>> Shift\n\n\n      var numShiftX = shiftX === true ? 0 : shiftX;\n\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleArea.left) {\n          nextOffsetX -= nextPopupX - visibleArea.left;\n\n          if (targetRect.x + targetWidth < visibleArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.left + targetWidth - numShiftX;\n          }\n        } // Right\n\n\n        if (nextPopupRight > visibleArea.right) {\n          nextOffsetX -= nextPopupRight - visibleArea.right;\n\n          if (targetRect.x > visibleArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.right + numShiftX;\n          }\n        }\n      }\n\n      var numShiftY = shiftY === true ? 0 : shiftY;\n\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleArea.top) {\n          nextOffsetY -= nextPopupY - visibleArea.top;\n\n          if (targetRect.y + targetHeight < visibleArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.top + targetHeight - numShiftY;\n          }\n        } // Bottom\n\n\n        if (nextPopupBottom > visibleArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleArea.bottom;\n\n          if (targetRect.y > visibleArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.bottom + numShiftY;\n          }\n        }\n      } // Arrow center align\n\n\n      var popupLeft = popupRect.x + nextOffsetX;\n      var popupRight = popupLeft + popupWidth;\n      var popupTop = popupRect.y + nextOffsetY;\n      var popupBottom = popupTop + popupHeight;\n      var targetLeft = targetRect.x;\n      var targetRight = targetLeft + targetWidth;\n      var targetTop = targetRect.y;\n      var targetBottom = targetTop + targetHeight;\n      var maxLeft = Math.max(popupLeft, targetLeft);\n      var minRight = Math.min(popupRight, targetRight);\n      var xCenter = (maxLeft + minRight) / 2;\n      var nextArrowX = xCenter - popupLeft;\n      var maxTop = Math.max(popupTop, targetTop);\n      var minBottom = Math.min(popupBottom, targetBottom);\n      var yCenter = (maxTop + minBottom) / 2;\n      var nextArrowY = yCenter - popupTop;\n      onPopupAlign === null || onPopupAlign === void 0 ? void 0 : onPopupAlign(popupEle, nextAlignInfo);\n      setOffsetInfo({\n        ready: true,\n        offsetX: nextOffsetX / _scaleX,\n        offsetY: nextOffsetY / _scaleY,\n        arrowX: nextArrowX / _scaleX,\n        arrowY: nextArrowY / _scaleY,\n        scaleX: _scaleX,\n        scaleY: _scaleY,\n        align: nextAlignInfo\n      });\n    }\n  });\n\n  var triggerAlign = function triggerAlign() {\n    alignCountRef.current += 1;\n    var id = alignCountRef.current; // Merge all align requirement into one frame\n\n    Promise.resolve().then(function () {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  }; // Reset ready status when placement & open changed\n\n\n  var resetReady = function resetReady() {\n    setOffsetInfo(function (ori) {\n      return _objectSpread(_objectSpread({}, ori), {}, {\n        ready: false\n      });\n    });\n  };\n\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(function () {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}","map":{"version":3,"names":["_objectSpread","_slicedToArray","isDOM","isVisible","useEvent","useLayoutEffect","React","collectScroller","getWin","toNum","num","Number","isNaN","splitPoints","points","arguments","length","undefined","getAlignPoint","rect","topBottom","leftRight","x","y","height","width","reversePoints","index","reverseMap","t","b","l","r","map","point","i","join","useAlign","open","popupEle","target","placement","builtinPlacements","popupAlign","onPopupAlign","_React$useState","useState","ready","offsetX","offsetY","arrowX","arrowY","scaleX","scaleY","align","_React$useState2","offsetInfo","setOffsetInfo","alignCountRef","useRef","scrollerList","useMemo","onAlign","popupElement","originLeft","style","left","originTop","top","doc","ownerDocument","win","placementInfo","targetRect","Array","isArray","getBoundingClientRect","popupRect","_win$getComputedStyle","getComputedStyle","_doc$documentElement","documentElement","clientWidth","clientHeight","scrollWidth","scrollHeight","scrollTop","scrollLeft","popupHeight","popupWidth","targetHeight","targetWidth","visibleArea","htmlRegion","right","bottom","forEach","ele","HTMLBodyElement","eleRect","eleOutHeight","offsetHeight","eleInnerHeight","eleOutWidth","offsetWidth","eleInnerWidth","Math","round","eleScrollWidth","eleScrollHeight","eleRight","eleBottom","max","min","_scaleX","parseFloat","_scaleY","offset","targetOffset","_ref","_ref2","_ref2$","popupOffsetX","_ref2$2","popupOffsetY","_ref3","_ref4","_ref4$","targetOffsetX","_ref4$2","targetOffsetY","_ref5","_ref6","popupPoint","targetPoint","targetPoints","popupPoints","targetAlignPoint","popupAlignPoint","nextAlignInfo","nextOffsetX","nextOffsetY","getIntersectionVisibleArea","visibleX","visibleY","visibleR","visibleB","originIntersectionVisibleArea","targetAlignPointTL","popupAlignPointTL","targetAlignPointBR","popupAlignPointBR","overflow","adjustX","adjustY","shiftX","shiftY","supportAdjust","val","nextPopupY","nextPopupBottom","needAdjustY","sameTB","tmpNextOffsetY","_tmpNextOffsetY","nextPopupX","nextPopupRight","needAdjustX","sameLR","tmpNextOffsetX","_tmpNextOffsetX","numShiftX","numShiftY","popupLeft","popupRight","popupTop","popupBottom","targetLeft","targetRight","targetTop","targetBottom","maxLeft","minRight","xCenter","nextArrowX","maxTop","minBottom","yCenter","nextArrowY","triggerAlign","current","id","Promise","resolve","then","resetReady","ori"],"sources":["/Users/chune/Documents/RMS Geoespacial/ERP/Emilus - React Admin Template/starter/node_modules/@rc-component/trigger/es/hooks/useAlign.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { isDOM } from \"rc-util/es/Dom/findDOMNode\";\nimport isVisible from \"rc-util/es/Dom/isVisible\";\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getWin } from \"../util\";\nfunction toNum(num) {\n  return Number.isNaN(num) ? 1 : num;\n}\nfunction splitPoints() {\n  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return [points[0], points[1]];\n}\nfunction getAlignPoint(rect, points) {\n  var topBottom = points[0];\n  var leftRight = points[1];\n  var x;\n  var y;\n\n  // Top & Bottom\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  }\n\n  // Left & Right\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction reversePoints(points, index) {\n  var reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  return points.map(function (point, i) {\n    if (i === index) {\n      return reverseMap[point] || 'c';\n    }\n    return point;\n  }).join('');\n}\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {\n  var _React$useState = React.useState({\n      ready: false,\n      offsetX: 0,\n      offsetY: 0,\n      arrowX: 0,\n      arrowY: 0,\n      scaleX: 1,\n      scaleY: 1,\n      align: builtinPlacements[placement] || {}\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    offsetInfo = _React$useState2[0],\n    setOffsetInfo = _React$useState2[1];\n  var alignCountRef = React.useRef(0);\n  var scrollerList = React.useMemo(function () {\n    if (!popupEle) {\n      return [];\n    }\n    return collectScroller(popupEle);\n  }, [popupEle]);\n\n  // ========================= Align =========================\n  var onAlign = useEvent(function () {\n    if (popupEle && target && open) {\n      var popupElement = popupEle;\n      var originLeft = popupElement.style.left;\n      var originTop = popupElement.style.top;\n      var doc = popupElement.ownerDocument;\n      var win = getWin(popupElement);\n\n      // Placement\n      var placementInfo = _objectSpread(_objectSpread({}, builtinPlacements[placement]), popupAlign);\n\n      // Reset first\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n\n      // Calculate align style, we should consider `transform` case\n      var targetRect;\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        var rect = target.getBoundingClientRect();\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      var popupRect = popupElement.getBoundingClientRect();\n      var _win$getComputedStyle = win.getComputedStyle(popupElement),\n        width = _win$getComputedStyle.width,\n        height = _win$getComputedStyle.height;\n      var _doc$documentElement = doc.documentElement,\n        clientWidth = _doc$documentElement.clientWidth,\n        clientHeight = _doc$documentElement.clientHeight,\n        scrollWidth = _doc$documentElement.scrollWidth,\n        scrollHeight = _doc$documentElement.scrollHeight,\n        scrollTop = _doc$documentElement.scrollTop,\n        scrollLeft = _doc$documentElement.scrollLeft;\n      var popupHeight = popupRect.height;\n      var popupWidth = popupRect.width;\n      var targetHeight = targetRect.height;\n      var targetWidth = targetRect.width;\n\n      // Get bounding of visible area\n      var visibleArea = placementInfo.htmlRegion === 'scroll' ?\n      // Scroll region should take scrollLeft & scrollTop into account\n      {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      } : {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      (scrollerList || []).forEach(function (ele) {\n        if (ele instanceof HTMLBodyElement) {\n          return;\n        }\n        var eleRect = ele.getBoundingClientRect();\n        var eleOutHeight = ele.offsetHeight,\n          eleInnerHeight = ele.clientHeight,\n          eleOutWidth = ele.offsetWidth,\n          eleInnerWidth = ele.clientWidth;\n        var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n        var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);\n        var eleScrollWidth = (eleOutWidth - eleInnerWidth) * scaleX;\n        var eleScrollHeight = (eleOutHeight - eleInnerHeight) * scaleY;\n        var eleRight = eleRect.x + eleRect.width - eleScrollWidth;\n        var eleBottom = eleRect.y + eleRect.height - eleScrollHeight;\n        visibleArea.left = Math.max(visibleArea.left, eleRect.left);\n        visibleArea.top = Math.max(visibleArea.top, eleRect.top);\n        visibleArea.right = Math.min(visibleArea.right, eleRight);\n        visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n      });\n\n      // Reset back\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n\n      // Calculate scale\n      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);\n\n      // No need to align since it's not visible in view\n      if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      }\n\n      // Offset\n      var offset = placementInfo.offset,\n        targetOffset = placementInfo.targetOffset;\n      var _ref = offset || [],\n        _ref2 = _slicedToArray(_ref, 2),\n        _ref2$ = _ref2[0],\n        popupOffsetX = _ref2$ === void 0 ? 0 : _ref2$,\n        _ref2$2 = _ref2[1],\n        popupOffsetY = _ref2$2 === void 0 ? 0 : _ref2$2;\n      var _ref3 = targetOffset || [],\n        _ref4 = _slicedToArray(_ref3, 2),\n        _ref4$ = _ref4[0],\n        targetOffsetX = _ref4$ === void 0 ? 0 : _ref4$,\n        _ref4$2 = _ref4[1],\n        targetOffsetY = _ref4$2 === void 0 ? 0 : _ref4$2;\n      targetRect.x += targetOffsetX;\n      targetRect.y += targetOffsetY;\n\n      // Points\n      var _ref5 = placementInfo.points || [],\n        _ref6 = _slicedToArray(_ref5, 2),\n        popupPoint = _ref6[0],\n        targetPoint = _ref6[1];\n      var targetPoints = splitPoints(targetPoint);\n      var popupPoints = splitPoints(popupPoint);\n      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      var popupAlignPoint = getAlignPoint(popupRect, popupPoints);\n\n      // Real align info may not same as origin one\n      var nextAlignInfo = _objectSpread({}, placementInfo);\n\n      // Next Offset\n      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n\n      // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n      function getIntersectionVisibleArea(x, y) {\n        var r = x + popupWidth;\n        var b = y + popupHeight;\n        var visibleX = Math.max(x, visibleArea.left);\n        var visibleY = Math.max(y, visibleArea.top);\n        var visibleR = Math.min(r, visibleArea.right);\n        var visibleB = Math.min(b, visibleArea.bottom);\n        return (visibleR - visibleX) * (visibleB - visibleY);\n      }\n      var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);\n\n      // ================ Overflow =================\n      var targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      var popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      var targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      var popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      var overflow = placementInfo.overflow || {};\n      var adjustX = overflow.adjustX,\n        adjustY = overflow.adjustY,\n        shiftX = overflow.shiftX,\n        shiftY = overflow.shiftY;\n      var supportAdjust = function supportAdjust(val) {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n        return val >= 0;\n      };\n\n      // >>>>>>>>>> Top & Bottom\n      var nextPopupY = popupRect.y + nextOffsetY;\n      var nextPopupBottom = nextPopupY + popupHeight;\n      var needAdjustY = supportAdjust(adjustY);\n      var sameTB = popupPoints[0] === targetPoints[0];\n\n      // Bottom to Top\n      if (needAdjustY && popupPoints[0] === 't' && nextPopupBottom > visibleArea.bottom) {\n        var tmpNextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n        if (getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY) > originIntersectionVisibleArea) {\n          nextOffsetY = tmpNextOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        }\n      }\n\n      // Top to Bottom\n      if (needAdjustY && popupPoints[0] === 'b' && nextPopupY < visibleArea.top) {\n        var _tmpNextOffsetY;\n        if (sameTB) {\n          _tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n        if (getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY) > originIntersectionVisibleArea) {\n          nextOffsetY = _tmpNextOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        }\n      }\n\n      // >>>>>>>>>> Left & Right\n      var nextPopupX = popupRect.x + nextOffsetX;\n      var nextPopupRight = nextPopupX + popupWidth;\n      var needAdjustX = supportAdjust(adjustX);\n\n      // >>>>> Flip\n      var sameLR = popupPoints[1] === targetPoints[1];\n\n      // Right to Left\n      if (needAdjustX && popupPoints[1] === 'l' && nextPopupRight > visibleArea.right) {\n        var tmpNextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n        if (getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY) > originIntersectionVisibleArea) {\n          nextOffsetX = tmpNextOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        }\n      }\n\n      // Left to Right\n      if (needAdjustX && popupPoints[1] === 'r' && nextPopupX < visibleArea.left) {\n        var _tmpNextOffsetX;\n        if (sameLR) {\n          _tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n        if (getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY) > originIntersectionVisibleArea) {\n          nextOffsetX = _tmpNextOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        }\n      }\n\n      // >>>>> Shift\n      var numShiftX = shiftX === true ? 0 : shiftX;\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleArea.left) {\n          nextOffsetX -= nextPopupX - visibleArea.left;\n          if (targetRect.x + targetWidth < visibleArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.left + targetWidth - numShiftX;\n          }\n        }\n\n        // Right\n        if (nextPopupRight > visibleArea.right) {\n          nextOffsetX -= nextPopupRight - visibleArea.right;\n          if (targetRect.x > visibleArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.right + numShiftX;\n          }\n        }\n      }\n      var numShiftY = shiftY === true ? 0 : shiftY;\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleArea.top) {\n          nextOffsetY -= nextPopupY - visibleArea.top;\n          if (targetRect.y + targetHeight < visibleArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.top + targetHeight - numShiftY;\n          }\n        }\n\n        // Bottom\n        if (nextPopupBottom > visibleArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleArea.bottom;\n          if (targetRect.y > visibleArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.bottom + numShiftY;\n          }\n        }\n      }\n\n      // Arrow center align\n      var popupLeft = popupRect.x + nextOffsetX;\n      var popupRight = popupLeft + popupWidth;\n      var popupTop = popupRect.y + nextOffsetY;\n      var popupBottom = popupTop + popupHeight;\n      var targetLeft = targetRect.x;\n      var targetRight = targetLeft + targetWidth;\n      var targetTop = targetRect.y;\n      var targetBottom = targetTop + targetHeight;\n      var maxLeft = Math.max(popupLeft, targetLeft);\n      var minRight = Math.min(popupRight, targetRight);\n      var xCenter = (maxLeft + minRight) / 2;\n      var nextArrowX = xCenter - popupLeft;\n      var maxTop = Math.max(popupTop, targetTop);\n      var minBottom = Math.min(popupBottom, targetBottom);\n      var yCenter = (maxTop + minBottom) / 2;\n      var nextArrowY = yCenter - popupTop;\n      onPopupAlign === null || onPopupAlign === void 0 ? void 0 : onPopupAlign(popupEle, nextAlignInfo);\n      setOffsetInfo({\n        ready: true,\n        offsetX: nextOffsetX / _scaleX,\n        offsetY: nextOffsetY / _scaleY,\n        arrowX: nextArrowX / _scaleX,\n        arrowY: nextArrowY / _scaleY,\n        scaleX: _scaleX,\n        scaleY: _scaleY,\n        align: nextAlignInfo\n      });\n    }\n  });\n  var triggerAlign = function triggerAlign() {\n    alignCountRef.current += 1;\n    var id = alignCountRef.current;\n\n    // Merge all align requirement into one frame\n    Promise.resolve().then(function () {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  };\n\n  // Reset ready status when placement & open changed\n  var resetReady = function resetReady() {\n    setOffsetInfo(function (ori) {\n      return _objectSpread(_objectSpread({}, ori), {}, {\n        ready: false\n      });\n    });\n  };\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(function () {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}